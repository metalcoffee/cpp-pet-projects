# Лабораторная работа №3 (mytest)

## Содержание

1. [Содержание](#содержание)
1. [Задание](#задание)
    1. [Советы](#советы)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Базовые требования](#базовые-требования)
    1. [Дополнительные требования](#дополнительные-требования)
    1. [Частичные решения](#частичные-решения)
1. [Инструкция по сдаче](#инструкция-по-сдаче)
1. [Система оценки](#система-оценки)
1. [Сроки сдачи](#сроки-сдачи)

## Задание
Реализуйте библиотеку `mytest` для написания юнит-тестов вроде [onqtam/doctest](https://github.com/onqtam/doctest).
Должны поддерживаться макросы `TEST_CASE`, `CHECK`, `CHECK_MESSAGE` и упрощённый `SUBCASE`.

Каждый `TEST_CASE` считается пройденным тогда и только тогда, когда все условия `CHECK`/`CHECK_MESSAGE`
внутри него оказались истинны.

Библиотека состоит из:

* Заголовочного файла `mytest.h`, который используется пользователем библиотеки.
* Единицы трансляции `mytest.cpp`.
* Единицы трансляции `mytest_main.cpp` с реализацией `int main()`.
* Заголовочного файла `mytest_internal.h`, который используется только `mytest.cpp` и `mytest_main.cpp`.

Должны корректно компилироваться и компоноваться (линковаться) два вида программ,
использующих `mytest`:

* Включающие единицу трансляции `mytest_main.cpp` — в этом случае запускаются все тесты.
* Не включающие единицу трансляции `mytest_main.cpp`, но включающие `mytest.cpp` — в этом случае
  должен запускаться предоставленный пользователем `main()`, а весь код внутри `TEST_CASE`
  по сути игнорируется.

Таким образом, пользователь `mytest` может писать тесты вперемешку со своим основным кодом
и они не будут ему мешать.

Использовать `doctest` запрещается.

### Советы
* `clang-tidy` запрещает использовать макросы, однако они требуются в `mytest.h`.
  Также иногда возможны ложноположительные срабатывания в заголовках; например,
  на неиспользуемые поля.
  Это нужно заглушить.
* Чтобы не дублировать много кода между `CHECK` и `CHECK_MESSAGE`, создайте вспомогательную
  функцию и гляньте на `std::optional`.
* Так как автотестам требуется компилировать ваше решение, они пытаются найти компилятор при помощи `detect-compiler.sh`.
  Если не получилось сразу, то вы можете:
  * Запустить автотесты из `Developer Command Prompt for VS 2019`, если используете только Visual Studio.
    Должен появиться компилятор `cl.exe`.
  * Передать скрипту `./run-test-data.sh` в качестве аргументов команду для компиляции в файл с именем `compiled-test`,
    например: `./run-test-data.sh g++-10 -o compiled-test -g`.
  * Скомпилировать каждый из примеров самостоятельно в файл `compiled-test` в соответствующей папке,
    закомментировать в `run-test.data` строчку с запуском `"${COMPILER_CMD[@]}" $SOURCES` (комментарии в Bash — `#` в начале строки)
    и запустить автотесты.
* Будьте аккуратны с именами в макросах: по возможности используйте полностью квалифицированные
  имена: `::mytest::foo()` вместо `foo()`.
* Чтобы правильно реализовать макрос `TEST_CASE`, используйте идеи и код из упражнений
  `05-211004/10-new-var`,
  `05-211004/11-new-func.cpp`,
  `06-211011/02-unnamed-namespace`,
  `06-211011/03-siof`.
  Иначе может произойти коллизия имён.
* Если вам надо сохранить свободную функцию или лямбда-функцию (не метод) в переменную, воспользуйтесь
  `std::function<void()>` (если функция ничего не принимает и не возвращает).
  * Более эффективный и сложный способ для свободных функций (но не лямбд с захватами) — указатели на функции.
* Чтобы реализовать вложенные `SUBCASE`, вам потребуется как-то узнать о завершении подтеста.
  Для этого вы можете создать внутри `for`/`while` (или даже `if`, начиная с C++17)
  временную переменную с __деструктором__ — специальной функцией, которая вызывается при удалении переменной:
  ```c++
  struct Foo {
      Foo() { std::cout << "Created!\n"; }
      ~Foo() { std::cout << "Destroyed!\n"; }
      // Требуется для clang-tidy, потом разберём
      Foo(const Foo &) = delete;
      Foo(Foo &&) = delete;
      Foo &operator=(const Foo &) = delete;
      Foo &operator=(Foo &&) = delete;
  };
  // ...
  if (Foo f; 2 * 2 == 4) {  // Created!
      std::cout << "inside\n";
  }  // Destroyed!
  ```
* К сожалению, Visual Studio может не обработать конструкцию `[[maybe_unused]] ::mytest::Foo foo;`.
  Можно переписать: `::mytest::Foo foo [[maybe_unused]];`.

## Требования к корректности решения
### Базовые требования
Действуют [стандартные требования](../common/).

Так как проект состоит из множества файлов в разных папках,
к некоторым командам потребуется добавить ключи `-I` (`-extra-arg=-I` в случае `clang-tidy`).

Обратите внимание, что также [немного изменились](https://github.com/hse-spb-2021-cpp/labs/commit/d7744bf9d4d40916d5c950f76ad6492253eb57d5) ключи запуска `cppcheck` и Visual Studio.

### Дополнительные требования
* Все определения должны быть по максимуму вынесены в `mytest_main.cpp` и в `mytest.cpp`.
* В `mytest.h` остаётся только самый минимум, который нужен пользователю библиотеки.
  Общие для `mytest.cpp`/`mytest_main.cpp` объявления можно вынести в `mytest_internal.h`.
* Все сущности библиотеки должны находиться внутри пространства имён `::mytest`.
* Так как макросы не могут находиться внутри пространства имён, все внутренние для библиотеки
  макросы должны начинаться с `MYTEST_INTERNAL_`.
* Имена всех сущностей, генерируемых макросами, должны начинаться с `mytest_`.
* Запрещается использовать `__COUNTER__` — это нестандартное расширение.
  Можно использовать `__LINE__`

### `CHECK` и `CHECK_MESSAGE`
Макрос `CHECK(expr)` вычисляет выражение `expr` ровно один раз.
Если получилось истинное значение, ничего не происходит.
Иначе в стандартный поток ошибок (`std::cerr`) выводится сообщение в следующем формате,
содержащее строковое представление `expr`, имя файла и строку,
где располагался вызов `CHECK`:

```
CHECK(2 * 2 == 5) at demo/demo1.cpp:8 failed!
```

Допускается выводить полный путь к файлу, не требуется как-то обрабатывать результат подстановки `__FILE__`.

Макрос `CHECK_MESSAGE(expr, msg)` ведёт себя аналогично, но в сообщении
об ошибке также добавляется сообщение `msg` (это строка, необязательно литерал):

```
CHECK(2 * 2 == 5) at demo/demo2.cpp:13 failed!
    message: demo2-msg2
```

* Оба макроса должны вести себя как вызов функции, возвращающей `void`.
* Если программа компилируется в режиме запуска тестов, то оба макроса будут вызываться только внутри `TEST_CASE`.
* Если программа компилируется в режиме запуска пользовательского `main()`, то оба макроса могут вызываться вне `TEST_CASE`.
  * [Extra reading](https://github.com/Nekrolm/ubbook/issues/57): при этом гарантируется, что стандартный ввод-вывод будет проинициализирован до вызова макроса.
* Ни один макрос никогда не прерывает выполнение программы.

### `TEST_CASE`
После макроса `TEST_CASE(name)` обязательно идут фигурные скобки с текстом теста.
Он может встретиться только там, где может встретиться определение свободной функции.

* `name` — произвольный строковой литерал.
* Фреймворк не должен требовать от пользователя как-то определять тесты, кроме как `TEST_CASE`.
* В одной строчке файла не может встретиться два `TEST_CASE`.
* Тесты должны выполняться в лексикографическом порядке: отсортированы по имени теста.
* Если тесты пройдены, `mytest_main.cpp` должен завершаться с нулевым кодом возврата, иначе — с кодом возврата 1.

Перед началом тестирования каждого теста в стандартный поток ошибок выводится сообщение
с именем теста:

```
Running "Demo1.cpp test case 1"...
```

После окончания всех тестов выводится статистика по количеству пройденных и запущенных тестов:

```
===== Tests passed: 2/5 =====
```

### `SUBCASE`
Внутри `TEST_CASE` можно выделять несколько блоков `SUBCASE(name)`, в том числе вложенных.

* Трактуем `SUBCASE(name)` как предложение (statement) вроде `if`/`for`, причём
  после него гарантированно идут фигурные скобки с телом подслучая.
* `name` — произвольная строка. Необязательно литерал, может генерироваться динамически.
* В одной строчке файла не может встретиться два `SUBCASE`.
* Можно считать, что максимальная вложенность `SUBCASE` небольшая.

Блоки `SUBCASE` выполняются следующим образом.

1. Строится упорядоченный список `X` из `SUBCASE`, внутри которых нет других `SUBCASE`.
   Порядок — как при выполнении программы.
   Например, цикл может сгенерировать несколько разных `SUBCASE`.
2. Каждый случай `x` из `X` выполняется, причём при выполнении случая `x`
   также выполняются те, в которые он вложен.
   * Между запусками случаев выводите в стандартный поток вывода сообщение:
     ```
     ...another subcase...
     ```
3. Если в какой-то момент `CHECK`/`CHECK_MESSAGE` выдали ошибку,
   то текущий случай обрабатывается до конца, а вот следующие случаи из списка `X` не выполняются.

Например, в следующем коде:

```c++
TEST_CASE("Subcase test") {
    std::cerr << "1";
    SUBCASE("a") {
        std::cerr << "2";
        SUBCASE("b") {
            std::cerr << "3";
        }
        SUBCASE("c") {
            std::cerr << "4";
        }
        std::cerr << "5";
    }
    std::cerr << "6";
    SUBCASE("d") {
        std::cerr << "7";
        SUBCASE("e") {
            std::cerr << "8";
        }
        SUBCASE("f") {
            std::cerr << "9";
        }
    }
    std::cerr << "end\n";
}
```

будет построен список `X` из `SUBCASE("b")`, `SUBCASE("c")`, `SUBCASE("e")`, `SUBCASE("f")`.
При выполнении каждого из них также запустится окружающий код `SUBCASE("a")` или `SUBCASE("d")`.
На экран выведется `12356end` для первого (`a`, `b`), `12456end` для второго (`a`, `c`),
`1678end` для третьего (`d`, `e`) и `1679end` для четвёртого (`d`, `f`).

А если в примере выше после `std::cerr << "2"` добавить `CHECK(false)`,
то будет запущен только один подслучай (`a`, `b`) и на экран выведется `12356end`.

Также `CHECK` и `CHECK_MESSAGE` при ошибке должны выводить на экран и
путь до текущего `SUBCASE`, например:

```
CHECK(false) at subcases.cpp:14 failed!
    message: msg2
    in subcase a
    in subcase b
```

Если же выполнение ещё не дошло до самого вложенного `SUBCASE` (то есть до элемента списка `X`),
то выводится лишь префикс сообщений `in subcase`.

### Частичные решения
Вы можете реализовать любой префикс из пяти подзаданий ниже и получить частичные баллы.

1. Только макросы `CHECK` и `CHECK_MESSAGE`.
1. Добавляется макрос `TEST_CASE`.
   Гарантируется, что итоговая программа состоит из трёх единиц трансляции:
   `mytest.cpp`, `mytest_main.cpp` и одна единица трансляции с тестами.
   Однако порядок инициализации глобальных переменных между разными единицами
   трансляции, разумеется, как обычно неизвестен.
3. Теперь программа может содержать любое количество единиц трансляции с тестами.
4. Добавляется макрос `SUBCASE`, однако `SUBCASE` не могут вкладываться друг в друга.
5. Ограничения отсутствуют.

## Инструкция по сдаче
[Схема стандартная](../common/#формат-сдачи): вы должны выполнить
задание в отдельной ветке и создать Pull Request.
В этом задании должно хватить веб-интерфейса GitHub, если возникают проблемы — попросите практика помочь.

Если вы хотите сдать только некоторые части задания, удалите остальные тесты из `tests.txt`.

## Система оценки
* Задание оценивается в 10 баллов: 6 за корректность, 4 за стиль.
  * Если не проходит хотя бы одна автопроверка или неверно назван PR, вы получаете ноль.
  * Вы не можете получить за стиль больше баллов, чем за корректность.
* Вы можете сдать любой префикс частей:
  |Выполненные части|Макс. корректность|Макс. стиль|Макс. итог|
  |---|---|---|---|
  |1  |0.5|0.5| 1|
  |1-2|1.5|1.5| 3|
  |1-3|3  |2  | 5|
  |1-4|4  |3  | 7|
  |1-5|6  |4  |10|

## Сроки сдачи
Первая версия задания выдана 11 октября 2021 (понедельник),
окончательная появилась 14 октября 2021 (четверг).
Ниже в каждом случае указано московское время.

* **Дедлайн сдачи:** 20 октября 2021 (среда), **22**:59.
* Ожидаемый срок проверки: 8 ноября (понедельник).
* Если первая попытка сдачи достаточно разумна (на усмотрение принимающего),
  то вы можете сделать ещё попытку исправлений или даже несколько.
  * Предложение актуально даже если вы получили автоматический ноль за первую попытку.
  * Выставляется максимум из всех попыток.
* **Срок исправлений**: 15 ноября 2021 (понедельник), **22**:59.
