# Лабораторная работа №2 (bigint)

## Содержание

1. [Содержание](#содержание)
1. [Задание](#задание)
    1. [Советы](#советы)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Базовые требования](#базовые-требования)
    1. [Дополнительные требования](#дополнительные-требования)
    1. [Частичные решения](#частичные-решения)
1. [Инструкция по сдаче](#инструкция-по-сдаче)
1. [Система оценки](#система-оценки)
1. [Сроки сдачи](#сроки-сдачи)

## Задание

Реализуйте «длинную арифметику», то есть класс (структуру), хранящий внутри себя числа произвольной длины и поддерживающий базовые арифметические операции с ними.
Для упрощения реализации, нужно поддержать только беззнаковую целочисленную арифметику, то есть поддерживаются только неотрицательные числа.

Решение должно быть оформлено в виде класса `bigint`.
Вы можете реализовать только часть операций или пользоваться дополнительными предположениями, смотри [частичные решения](#частичные-решения).

Для удобства работы и тестирования `bigint` должен уметь конструироваться из строки и из числа типа `unsigned int`. Весь остальной зоопарк целочисленных типов можно не реализовывать.

```C++
bigint x("179"), y(57);  // Создаёт числа 179 и 57, соответственно.
```

Числа нужно уметь сравнивать между собой, а также с числами типа `unsigned int`. Можно не поддерживать другие целочисленные типы, в том числе `int` и `unsigned long long`.

```C++
bigint x("179"), y("57");
std::cout << std::boolalpha
          << (x == y) << " "
          << (x != 57) << " "
          << (179 < y) << " "
          << (y >= x) << std::endl;  // Должен вывести "false true false false".
```

Из простых арифметических действий требуется поддерживать только сложение и вычитание. Можно считать, что в случае, если в результате вычитания получаются отрицательные числа, поведение неопределено (т.е. гарантируется, что в тестах такого не бывает). Точно так же нужно уметь складывать и вычитать с `unsigned int`.

```C++
bigint x("179"), y("57");
std::cout << std::boolalpha
          << (x + y == bigint("236")) << " "
          << (x - 57 == bigint("122")) << " "
          << (200 - x == bigint("21")) << std::endl;  // Должен вывести "true trtue true".
```

Кроме того, нужно поддерживать операторы присваивания, в том числе `+=` и `-=`, в том числе с аргументами типа `unsigned int`.

```C++
bigint x("179"), y("57");
x += y;
x -= 57;
y += 122;
std::cout << std::boolalpha << (x == y) << std::endl;  // Должен вывести "true".
```

Также требуется поддерживать постфиксные и префиксные инкременты и декременты (все четыре комбинации).

```C++
bigint x("179");
x++;
++x;
x--;
--x;
std::cout << std::boolalpha << (x == 179) << std::endl; // Должен вывести "true".
```

Также нужно уметь поддерживать преобразование `bigint` в строки (для чего нужно реализовать метод `to_string()`, возвращающий `std::string`), ввод и вывод. При реализации ввода можно рассчитывать на то, что ввод всегда будет корректный (то есть гарантируется, что в тестах не бывает иначе).

```C++
bigint x("179");
std::cout << x.to_string() << std::endl;  // Должен вывести "179" (без кавычек).
std::cout << x << std::endl;  // Должен вывести "179" (без кавычек).
bigint y;
std::cin >> y;  // Должен прочитать число со стандартного ввода.
```

### Советы
* При реализации всегда помните про ведущие нули.
* Храните цифры в векторе, а не строчке — так и проще поддержать произвольное основание системы счисления, и в коде меньше лишних операций вроде `- '0'` и `+ '0'`.
* Возможно, для реализации сложения и вычитания в столбик окажется проще хранить числа в перевёрнутом виде (то есть первый элемент вектора — младшая цифра числа).
* Реализовывайте бинарные операторы как функции вне класса, а не как методы.
    * В таком случае при наличии конструктора от `unsigned int` при вызове `2 + bigint("123")` сработает неявное преобразование и перегрузка `operator+(const bigint&, const bigint&)` подойдёт.
    * Это позволяет избежать дублирования кода.
    * При необходимости пользуйтесь `friend`.
* Реализовывать `operator=` не надо — в правильной реализации вас устроит его стандартное поведение: переприсвоивать каждое поле по отдельности.
    * А конструкции вида `a = 10` должны успешно работать через неявное преобразование числа к `bigint`.
* Начиная с C++17 вы можете создать константу, которая вычисляется из других констант хитрым образом, при помощи [IIFE](https://www.cppstories.com/2016/11/iife-for-complex-initialization/)
  (immediately invoked function expression):
  ```c++
  const int FIB_10 = []() {
      int a = 0, b = 1;
      for (int i = 0; i < 10; i++) {
          int c = a + b;
          a = b;
          b = c;
      }
      return a;
  }();  // Созданное лямбда-выражение сразу вызывается
  // Теперь FIB_10 равно 55.
  ```
* Если у вас возникают проблемы с алгоритмической частью (сложение, вычитание) — обращайтесь к практикам по C++ или алгоритмам.
* Перегрузки `operator>>` и `operator<<` принимают слева и возвращают не `std::stringstream&`,
  а `std::istream&` (для чтения) и `std::ostream&` (для вывода).
  Эти типы — обобщение всех потоков вводы/вывода, соответственно.
  Extra reading: [баг то ли в компиляторе, то ли на cppreference](https://stackoverflow.com/questions/69320918/why-does-taking-istream-to-a-temporary-stringstream-works-but-not-when-tak),
  спасибо Марку Ипатову за вопрос.

## Требования к корректности решения
### Базовые требования
Действуют [стандартные требования](../common/).

Начиная с этого задания на файлах с тестами для `doctest` для `clang-tidy` отключена проверка `readability-function-cognitive-complexity`.

Также начиная с этого задания следует помечать некоторые функции `[[nodiscard]]`, а некоторые конструкторы и операторы преобразования — `explicit`.

### Дополнительные требования
* Длинное число должно храниться в динамическом массиве по цифрам в системе счисления
  с основанием `BASE`.
  * Константа `BASE` должна задаваться в начале файла `bigint.inc.cpp` ровно как в заглушке.
    Можно дописать перед ней какие-то `#include`.
  * `BASE` всегда является степенью десятки, строго большей единицы.
  * Гарантируется, что числа `-2 * BASE` и `2 * BASE` помещаются в `int`.
  * Значение `BASE` не влияет на ввод и вывод: они всегда десятичные.
    То есть при изменении `BASE` тесты менять не нужно.
  * Ваше решение должно автоматически подстраиваться, если изменить только `BASE`.
    В частности, нельзя создавать другие константы, которые надо вручную изменить при изменении `BASE`.
* Семантика всех операций должна быть как можно ближе к `unsigned int`.
* Каждая операция с числом должна быть как можно эффективнее: сначала важна асимптотика,
  потом важно количество (пере)выделений памяти (в том числе внутри `vector`, `string`, `stringstream`), затем всё остальное.
  * При этом считаем, что выделение вектора размера O(1) бесплатно.
    Этого можно добиться при помощи [boost::small_vector](https://www.boost.org/doc/libs/1_77_0/doc/html/boost/container/small_vector.html) или его аналога вместо `std::vector`,
    но вам это делать не требуется.

### Частичные решения
Вы можете реализовать любой префикс из шести подзаданий ниже и получить частичные баллы.

Если ваше решения не работает при `BASE != 10`, вы получаете не больше половины баллов.
Если ваше решение ломается при появлении ведущих нулей, а они разрешены, то вы получаете не больше половины баллов.
Акции объединяются: если решение не работает ни с `BASE != 0`, ни с ведущими нулями, вы не можете получить за задание больше 2.5/10.

1. Реализуйте:
    * Конструирование `bigint` от непустой строки из цифр и от `unsigned int`.
      Ведущие нули запрещены, кроме строки `"0"`.
    * Шесть операторов для сравнения чисел.
      Должны работать в том числе в выражениях со смешением `bigint` и `unsigned int`.
    * Метод `to_string()`, преобразовывающий число в строку.
1. Реализуйте оператор явного (explicit) преобразования в `unsigned int`.
   Также с этого момента разрешаются ведущие нули во входных данных, в выходных данных ведущие нули запрещены.
1. Реализуйте операторы `+` и `+=`.
1. Реализуйте операторы `-` и `-=`.
1. Реализуйте постфиксные и префиксные унарные операторы `++` и `--`.
1. Реализуйте операторы `<<` и `>>` для ввода-вывода.

## Инструкция по сдаче
[Схема стандартная](../common/#формат-сдачи): вы должны выполнить
задание в отдельной ветке и создать Pull Request.
В этом задании должно хватить веб-интерфейса GitHub, если возникают проблемы — попросите практика помочь.

Если вы хотите сдать только некоторые части задания, закомментируйте строки вида `#define TEST_9`
для остальных частей в файле `tests.cpp`, чтобы отключить соответствующие автотесты.

## Система оценки
* Задание оценивается в 10 баллов: 6 за корректность, 4 за стиль.
  * Если не проходит хотя бы одна автопроверка или неверно назван PR, вы получаете ноль.
  * Вы не можете получить за стиль больше баллов, чем за корректность.
* Вы можете сдать любой префикс частей:
  |Выполненные части|Макс. корректность|Макс. стиль|Макс. итог|
  |---|---|---|---|
  |1  |1  |1  | 2|
  |1-2|1.5|1.5| 3|
  |1-3|2.5|2.5| 5|
  |1-4|3.5|3  | 7|
  |1-5|5  |4  | 9|
  |1-6|6  |4  |10|

## Сроки сдачи
Задание выдано 20 сентября 2021 (понедельник).
Ниже в каждом случае указано московское время.

* **Дедлайн сдачи:** 27 сентября 2021 (понедельник), **22**:59.
* Ожидаемый срок проверки: 4 октября (понедельник).
* Если первая попытка сдачи достаточно разумна (на усмотрение принимающего),
  то вы можете сделать ещё попытку исправлений или даже несколько.
  * Предложение актуально даже если вы получили автоматический ноль за первую попытку.
  * Выставляется максимум из всех попыток.
* **Срок исправлений**: 11 октября 2021 (понедельник), **22**:59.
