# Bigint-02

## Содержание

1. [Содержание](#содержание)
1. [Задание](#задание)
    1. [Советы](#советы)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Базовые требования](#базовые-требования)
    1. [Дополнительные требования](#дополнительные-требования)

## Задание

Реализуйте «длинную арифметику», то есть класс (структуру), хранящий внутри себя числа произвольной длины и поддерживающий базовые арифметические операции с ними.
Для упрощения реализации, нужно поддержать только беззнаковую целочисленную арифметику, то есть поддерживаются только неотрицательные числа.

Решение должно быть оформлено в виде класса `bigint`.
Вы можете реализовать только часть операций или пользоваться дополнительными предположениями, смотри [частичные решения](#частичные-решения).

Для удобства работы и тестирования `bigint` должен уметь конструироваться из строки и из числа типа `unsigned int`. Весь остальной зоопарк целочисленных типов можно не реализовывать.

```C++
bigint x("179"), y(57);  // Создаёт числа 179 и 57, соответственно.
```

Числа нужно уметь сравнивать между собой, а также с числами типа `unsigned int`. Можно не поддерживать другие целочисленные типы, в том числе `int` и `unsigned long long`.

```C++
bigint x("179"), y("57");
std::cout << std::boolalpha
          << (x == y) << " "
          << (x != 57) << " "
          << (179 < y) << " "
          << (y >= x) << std::endl;  // Должен вывести "false true false false".
```

Из простых арифметических действий требуется поддерживать только сложение и вычитание. Можно считать, что в случае, если в результате вычитания получаются отрицательные числа, поведение неопределено (т.е. гарантируется, что в тестах такого не бывает). Точно так же нужно уметь складывать и вычитать с `unsigned int`.

```C++
bigint x("179"), y("57");
std::cout << std::boolalpha
          << (x + y == bigint("236")) << " "
          << (x - 57 == bigint("122")) << " "
          << (200 - x == bigint("21")) << std::endl;  // Должен вывести "true trtue true".
```

Кроме того, нужно поддерживать операторы присваивания, в том числе `+=` и `-=`, в том числе с аргументами типа `unsigned int`.

```C++
bigint x("179"), y("57");
x += y;
x -= 57;
y += 122;
std::cout << std::boolalpha << (x == y) << std::endl;  // Должен вывести "true".
```

Также требуется поддерживать постфиксные и префиксные инкременты и декременты (все четыре комбинации).

```C++
bigint x("179");
x++;
++x;
x--;
--x;
std::cout << std::boolalpha << (x == 179) << std::endl; // Должен вывести "true".
```

Также нужно уметь поддерживать преобразование `bigint` в строки (для чего нужно реализовать метод `to_string()`, возвращающий `std::string`), ввод и вывод. При реализации ввода можно рассчитывать на то, что ввод всегда будет корректный (то есть гарантируется, что в тестах не бывает иначе).

```C++
bigint x("179");
std::cout << x.to_string() << std::endl;  // Должен вывести "179" (без кавычек).
std::cout << x << std::endl;  // Должен вывести "179" (без кавычек).
bigint y;
std::cin >> y;  // Должен прочитать число со стандартного ввода.
```

### Советы
* При реализации всегда помните про ведущие нули.
* Храните цифры в векторе, а не строчке — так и проще поддержать произвольное основание системы счисления, и в коде меньше лишних операций вроде `- '0'` и `+ '0'`.
* Возможно, для реализации сложения и вычитания в столбик окажется проще хранить числа в перевёрнутом виде (то есть первый элемент вектора — младшая цифра числа).
* Реализовывайте бинарные операторы как функции вне класса, а не как методы.
    * В таком случае при наличии конструктора от `unsigned int` при вызове `2 + bigint("123")` сработает неявное преобразование и перегрузка `operator+(const bigint&, const bigint&)` подойдёт.
    * Это позволяет избежать дублирования кода.
    * При необходимости пользуйтесь `friend`.
* Реализовывать `operator=` не надо — в правильной реализации вас устроит его стандартное поведение: переприсвоивать каждое поле по отдельности.
    * А конструкции вида `a = 10` должны успешно работать через неявное преобразование числа к `bigint`.
* Начиная с C++17 вы можете создать константу, которая вычисляется из других констант хитрым образом, при помощи [IIFE](https://www.cppstories.com/2016/11/iife-for-complex-initialization/)
  (immediately invoked function expression):
  ```c++
  const int FIB_10 = []() {
      int a = 0, b = 1;
      for (int i = 0; i < 10; i++) {
          int c = a + b;
          a = b;
          b = c;
      }
      return a;
  }();  // Созданное лямбда-выражение сразу вызывается
  // Теперь FIB_10 равно 55.
  ```
* Если у вас возникают проблемы с алгоритмической частью (сложение, вычитание) — обращайтесь к практикам по C++ или алгоритмам.
* Перегрузки `operator>>` и `operator<<` принимают слева и возвращают не `std::stringstream&`,
  а `std::istream&` (для чтения) и `std::ostream&` (для вывода).
  Эти типы — обобщение всех потоков вводы/вывода, соответственно.
  Extra reading: [баг то ли в компиляторе, то ли на cppreference](https://stackoverflow.com/questions/69320918/why-does-taking-istream-to-a-temporary-stringstream-works-but-not-when-tak),
  спасибо Марку Ипатову за вопрос.

## Требования к корректности решения
### Базовые требования
Действуют [стандартные требования](../common/).

Начиная с этого задания на файлах с тестами для `doctest` для `clang-tidy` отключена проверка `readability-function-cognitive-complexity`.

Также начиная с этого задания следует помечать некоторые функции `[[nodiscard]]`, а некоторые конструкторы и операторы преобразования — `explicit`.

### Дополнительные требования
* Длинное число должно храниться в динамическом массиве по цифрам в системе счисления
  с основанием `BASE`.
  * Константа `BASE` должна задаваться в начале файла `bigint.inc.cpp` ровно как в заглушке.
    Можно дописать перед ней какие-то `#include`.
  * `BASE` всегда является степенью десятки, строго большей единицы.
  * Гарантируется, что числа `-2 * BASE` и `2 * BASE` помещаются в `int`.
  * Значение `BASE` не влияет на ввод и вывод: они всегда десятичные.
    То есть при изменении `BASE` тесты менять не нужно.
  * Ваше решение должно автоматически подстраиваться, если изменить только `BASE`.
    В частности, нельзя создавать другие константы, которые надо вручную изменить при изменении `BASE`.
* Семантика всех операций должна быть как можно ближе к `unsigned int`.
* Каждая операция с числом должна быть как можно эффективнее: сначала важна асимптотика,
  потом важно количество (пере)выделений памяти (в том числе внутри `vector`, `string`, `stringstream`), затем всё остальное.
  * При этом считаем, что выделение вектора размера O(1) бесплатно.
    Этого можно добиться при помощи [boost::small_vector](https://www.boost.org/doc/libs/1_77_0/doc/html/boost/container/small_vector.html) или его аналога вместо `std::vector`,
    но вам это делать не требуется.

####To compile:

* $ g++ -std=c++17 doctest_main.cpp -c
*
* $ g++ -std=c++17  tests.cpp doctest_main.o  -o a


