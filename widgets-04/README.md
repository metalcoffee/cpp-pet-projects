# Лабораторная работа №4 (widgets)

## Содержание

1. [Содержание](#содержание)
1. [Задание](#задание)
    1. [Лирическое отступление](#лирическое-отступление)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Дополнительные требования](#дополнительные-требования)
    1. [Метод `child_at`](#метод-child_at)
    1. [Виджет `ball_icon`](#виджет-ball_icon)
    1. [Контейнер `box`](#контейнер-box)
    1. [Контейнер `grid`](#контейнер-grid)
    1. [Метод `parent`](#метод-parent)
   
## Задание
Реализуйте недостающие классы и методы в игрушечной иерархии [виджетов](https://ru.wikipedia.org/wiki/%D0%AD%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D0%B0).

Все виджеты наследуются от базового класса `widget`.
Некоторые виджеты представляют собой простые элементы: кнопку с надписью (`button`) или иконку шарика (`ball_icon`).
Другие виджеты являются *контейнерами*: они наследуются от класса `container` и могут содержать внутри себя любые виджеты.
Разные контейнеры располагают дочерние виджеты разным образом.
Контейнер владеет своими дочерними виджетами, а каждый дочерний виджет знает родительский виджет.
Вложенность не ограничена.

Все виджеты в конце концов оказываются на экране.
У каждого виджета есть ширина и высота в пикселях: `width()` и `height()`.
Такой виджет занимает ровно `width() * height()` квадратных пикселей на экране.
Любые два виджета либо не пересекаются, либо один является (пра)родителем другого.
Некоторые виджеты могут иметь "дырки": например, вокруг дочерних виджетов в контейнере
может быть пустое пространство.

Виджеты мутабельны: их свойства можно менять (надпись на кнопке, радиус шарика, набор дочерних виджетов в контейнере).
Размеры не-контейнеров обновляются автоматически, 
После изменения дочерних виджетов в контейнере его следует обновить методом `update_layout()`.
Если изменять набор элементов в контейнере, он обновляется автоматически.

Точный интерфейс следует из тестов.

### Дополнительные требования
* Вам разрешается менять только файлы `abstract_widgets.h`, `ball_icon.h`, `box.h`, `grid.h`,
  а также комментировать тесты в `test_utils.h`.
* Класс `widget` и его наследники должны оставаться некопируемыми и неперемещаемыми.
* Ваше API должно быть невозможно случайно использовать некорректно.
  Например:
  * Если вы возвращаете владеющий указатель, вы должны возвращать `unique_ptr`,
    а не чистый указатель.
  * Не должно быть публичных методов, которые можно случайно вызвать и незаметно
    сломать инвариант.
* Методы `width()`/`height()`/`parent()` у любого виджета должны работать за константное время.
* Метод `child_at()` при вызове от пикселя за пределами ограничивающего прямоугольника (bounding box) должен работать за константное время.
  * Например, от отрицательных координат.
* Для любого виджета `struct foo` должен быть метод `make_foo(a, b, c)`, эквивалентный вызову `std::make_unique<foo>(a, b, c)`.
* Файлу `abstract_widgets.h` запрещено упоминать каких-либо наследников (например, нельзя делать их друзьями)
  или предполагать, что наследников `widget`/`container`, кроме указанных в задании, нет.


### Метод `child_at`
Метод `child_at(x, y)` позволяет узнать, находится ли пиксель `(x, y)` внутри виджета или какого-нибудь из его детей (в том числе прадетей).
Координаты начинаются от левого верхнего угла виджета с нуля, ось OX растёт вправо, ось OY — вниз.
Обратите внимание, что нумеруются именно квадратные пиксели, а не точки на координатной плоскости.
Например, внутри виджета размером `1*1` имеется ровно один пиксель: `(0, 0)`.

Если пиксель находится внутри какого-либо дочернего виджета (или виджета `this`), то возвращается невладеющий указатель на этот виджет.
Иначе, если пиксель находится вне всех виджетов, возвращается `nullptr`.

В общем случае виджет имеют прямоугольную форму (например, кнопка), поэтому разумно предоставить реализацию по умолчанию.

В этом подзадании вам также может потребоваться ещё что-то, кроме метода `child_at`.

### Виджет `ball_icon`
Виджет `ball_icon` соответствует одной круглой иконке-шарику радиусом `radius` квадратных пикселей.
Соответственно, ширина и высота этой иконки — `2 * radius + 1` пиксель.

Таким образом можно однозначно определить центральный квадратный пиксель.
Метод `child_at(x, y)` возвращает `this`, если евклидово расстояние от искомого пикселя до центрального не превышает радиус иконки.
Например, пиксели `(0, radius)` и `(2 * radius, radius)` принадлежат иконке, а вот `(0, 2 * radius + 1)` — уже нет.

Помимо унаследованных методов у `ball_icon` имеются два:

* `radius()` возвращает текущий радиус.
* `radius(new_radius)` изменяет радиус на `new_radius`.

### Контейнер `box`
Работает почти как [`QBoxLayout`](https://doc.qt.io/qt-6/qboxlayout.html):

* В конструкторе фиксируется вид `box`: горизонтальный (элемент перечисления `box::kind::HORIZONTAL`) или вертикальный (`box::kind::VERTICAL`).
  Этот вид поменять нельзя.
* Все дочерние элементы упорядочены и пронумерованы с нуля.
* Горизонтальный `box` рисует свои элементы слева направо вплотную друг к другу.
  Таким образом его ширина равна сумме ширин элементов, а высота — высоте максимального элемента.
  Элементы меньшей высоты выравниваются посередине с округлением вверх по экрану (в сторону уменьшения координаты Y).
  Вертикальный `box` работает аналогично, округление влево по экрану (в сторону уменьшения координаты X).
* Пустой `box` имеет размер 0 квадратных пикселей.

`box` наследуется от класса `container`, у которого есть метод `update_layout()`.
Этот метод заставляет контейнер обойти своих детей (нерекурсивно) и пересчитать свою высоту и ширину.

Помимо унаследованных методов у `box` имеются методы (здесь `n` — количество дочерних элементов):

* `size()` — возвращает количество дочерних элементов (`int`) за `O(1)`.
* `get(index)` — возвращает невладеющий указатель на дочерний элемент с номером `index`
  (нумерация с нуля) за `O(1)`.
* `add(child)` — добавляет в конец новый дочерний виджет `child`.
  Возвращает невладеющий указатель на добавленный виджет.
  Работает за `O(n)`, можно амортизировано.
* `remove(index)` — удаляет дочерний элемент с номером `index`,
  возвращает владеющий указатель на удалённый элемент.
  Работает за `O(n)`, можно амортизировано.

Метод `update_layout()` работает за `O(n)`.
Метод `child_at()` работает за `O(n)` плюс время работы `child_at()` для не более чем одного ребёнка.

### Контейнер `grid`
Работает почти как [`QGridLayout`](https://doc.qt.io/qt-6/qgridlayout.html), но не так гибко:

* В конструкторе фиксируется количество строк (`rows`) и столбцов (`columns`) таблицы.
  Это количество поменять нельзя.
* В каждой ячейке таблицы может непосредственно находиться не более одного дочернего элемента.
  При этом этот дочерний элемент может быть контейнером со своими дочерними элементами.
* Все ячейки рисуются в таблице без зазоров.
  Каждая строка/столбец принимает минимально возможный размер, чтобы поместились все элементы.
  В частности, пустые строки/столбцы имеют размер 0 пикселей.
* Если элемент меньше ячейки, то он выравнивается в левый верхний угол ячейки.

Помимо унаследованных методов у `grid` имеются методы (здесь `n` — количество дочерних элементов):

* `rows()`/`columns()` — возвращают количество строк/столбцов за `O(1)`.
* `get(row, column)` — возвращает невладеющий указатель на дочерний элемент в строке `row` и столбце `column`
  (нумерация с нуля) за `O(1)`.
  Если такого элемента нет, возвращает `nullptr`.
* `add(child, row, column)` — добавляет новый дочерний виджет `child` в строку `row` и столбец `column`.
  Старый элемент из этой ячейки удаляется.
  Возвращает невладеющий указатель на добавленный виджет.
  Работает за `O(rows+columns)`, можно амортизировано.
* `remove(row, column)` — удаляет дочерний элемент из строки `row` и столбца `column`,
  возвращает владеющий указатель на удалённый элемент.
  Работает за `O(rows+columns)`, можно амортизировано.

Метод `update_layout()` работает за `O(rows*columns)`.
Метод `child_at()` работает за `O(rows+columns)` плюс время работы `child_at()` для не более чем одного ребёнка.

### Метод `parent`
Добавьте _невиртуальный_ метод `widget::parent()`, возвращающий невладеющий указатель на родительский виджет
при его наличии, `nullptr` иначе.

Значение этого метода должно автоматически меняться при вызове методов `add`/`remove` у контейнеров.
При этом должно быть невозможно случайно изменить `parent` без использования контейнера.
Например, публичный (`public`) или даже защищённый (`protected`) сеттер в `widget` не подойдёт:
так любой виджет сможет установить себе произвольного родителя.
Нужно что-то чуть-чуть хитрее и безопаснее, хотя 100% безопасности не достичь.

## Compile
$ g++ -std=c++17 doctest_main.cpp -c

$ g++ -std=c++17 abstract_widgets.h button.h button_test.cpp doctest.h doctest_main.o placeholder.h test_utils.h ball_icon.h ball_icon_test.cpp box.h box_test.cpp 

