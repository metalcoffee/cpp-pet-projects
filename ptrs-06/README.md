# Лабораторная работа №6 (ptrs)

## Содержание

1. [Содержание](#содержание)
1. [Задание](#задание)
    1. [Советы](#советы)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Базовые требования](#базовые-требования)
    1. [Дополнительные требования](#дополнительные-требования)
    1. [Семантика умных указателей](#семантика-умных-указателей)
    1. [Поддерживаемые операции](#поддерживаемые-операции)
    1. [Гарантии](#гарантии)
    1. [Частичные решения](#частичные-решения)
1. [Инструкция по сдаче](#инструкция-по-сдаче)
1. [Система оценки](#система-оценки)
1. [Сроки сдачи](#сроки-сдачи)

## Задание
Реализуйте два шаблона класса для умных указателей на `T`: `unique_ptr<T, Deleter>` и `shared_ptr<T>`,
являющиеся упрощениями соответствующих шаблонов из `std::`.
В некоторых тонких местах поведения вашей упрощённой версии и стандартного умного указателя могут отличаться,
уточняйте по условию и у преподавателей.

`unique_ptr` должен быть move-only и уметь использовать произвольный функтор типа `Deleter` для удаления объекта.
Вы также должны самостоятельно реализовать функтор по умолчанию,
похожий на `std::default_delete`, который будет вызывать обычный оператор `delete`.

В `shared_ptr` поддержка произвольных функторов для удаления не требуется.

Не требуются преобразования между указателями на разные типы,
между `unique_ptr`/`shared_ptr`, а также поддержка `unique_ptr<T[]>` или `shared_ptr<T[]>`.
Точный набор поддерживаемых операций можно проверить через открытые тесты и проверить ниже в задании.

### Советы
* У шаблонов можно задать значение одному из параметров по умолчанию: `template<typename T = int>`.
  Параметры по умолчанию могут зависеть от предыдущих.
* Если вы скомпилируете тесты с `-DTEST_STD_PTRS`, то они протестируют `std::unique_ptr` и `std::shared_ptr` вместо ваших реализаций.
  Тесты должны проходить.
* Используйте `std::exchange` для упрощения кода.
* Очень много логики будет дублироваться. Подумайте, какой метод наиболее общий и через что лучше всё выразить.
  * Будьте осторожны: иногда вы можете так потерять производительность или потребовать лишние свойства у типа `T`.
* Если вы пишете библиотечный код (вроде умных указателей), вам надо думать про много крайних случаев: не все типы копируются, не у всех есть конструктор по умолчанию...
  * При этом мы ещё не умеем писать отдельный код для случаев "тип копируется"/"тип не копируется" и подобных, но в этом задании и не требуется.
    Достаточно того, что неиспользуемые методы у шаблонных структур не инстанцируются.
* Закомментируйте тесты, начните с тривиальной некорректной реализации `unique_ptr`,
  и двигайтесь от простого к сложному, раскомментируя тесты по очереди.
  * Например, тесты на incomplete type могут не скомпилироваться с первого раза.
* Шаблонные друзья и друзья для шаблонов — отдельная сложная тема.
  Проще всего реализовать нешаблонную функцию-друга (вроде `swap`) прямо внутри шаблонного класса и не разделять объявление с определением.
* Открытые тесты проверяют далеко не всю корректность.
  Например, какие-то хитрые типы `T` и `Deleter`.
* Будьте осторожны с самоприсваиванием: https://isocpp.org/wiki/faq/assignment-operators#self-assignment-what

## Требования к корректности решения
### Базовые требования
Действуют [стандартные требования](../common/), но:

* У `clang-tidy` отключены следующие проверки:
  * `cppcoreguidelines-owning-memory`
  * `performance-noexcept-move-constructor`
  * `bugprone-unhandled-self-assignment`
* Добавлено обязательное тестирование под Apple Clang на macOS в двух режимах
* Добавлено обязательное тестирование под Intel C++ Compiler Classic (не путать с Intel DPC++ Compiler) на Ubuntu в двух режимах

### Дополнительные требования
* Вы можете редактировать только существующие файлы `unique_ptr.h` и `shared_ptr.h`, а также комментировать `#define` в тестах для частичных баллов.
* Запрещается использовать стандартные умные указатели и `std::default_delete`.
* Минимизируйте количество перемещений/копирований/вызовов деструкторов у нетривиальных объектов.
  * Например, вместо принятия по значению может быть выгоднее сделать две перегрузки: одну с const lvalue-ссылкой, другой с rvalue-ссылкой.
* Запрещается создавать глобальные состояние.

### Семантика умных указателей
#### `unique_ptr`
`unique_ptr` либо хранит `nullptr`, либо единолично владеет указателем `T*` на некоторый объект
вместе со своим экземпляром функтора типа `Deleter` для освобождения объекта по этому указателю.
Копирование `unique_ptr` запрещено, перемещение разрешено (moved-from state — `nullptr`).
В конце жизни или при сбросе указателя `unique_ptr` должен при помощи `Deleter` освободить объект, которым владел.

В отличие от `std::unique_ptr`, в этом задании не разрешается вызывать функтор на `nullptr`.

#### `shared_ptr`
Каждый экземпляр `shared_ptr` либо хранит `nullptr`, либо совместно с другими `shared_ptr`
владеет указателем `T*` на некоторый объект.
Копирование и перемещение `shared_ptr` разрешено (moved-from state — `nullptr`).
Объект удаляется в точности когда больше не остаётся экземпляров `shared_ptr`, владеющих им.

`shared_ptr` могут создаваться и удаляться в любом порядке.
Копирование `shared_ptr` — единственный способ создать разделяемое владение.
Если создаётся два `shared_ptr` от одного и того же чистого указателя, разрешается double free.

### Поддерживаемые операции
Оба умных указателя должны иметь:

* Конструктор по умолчанию.
* Конструктор от `nullptr`.
* Конструктор от указателя, который требуется взять во владение.
* Перемещающий оператор присваивания.
* Перемещающий конструктор.
* Метод `get()` для получения текущего значения указателя.
* Метод `reset()`, сбрасывающий текущий указатель.
* Метод `reset(x)`, передающий владение обычным указателем `x` умному указателю.
* Перегруженные операторы `->` и `*`.
* Свободную функцию `swap()`.
* Оператор приведения к `bool`.
* Операторы `==` и `!=` для сравнения умных указателей одного типа.
  Указатели равны тогда и только тогда когда либо оба указывают на один и тот же объект, либо оба `nullptr`.

`unique_ptr` также должен иметь:

* Конструктор от указателя, который требуется взять во владение, и удаляющего функтора.
* Метод `release()`, "открепляющий" указатель от умного указателя и возвращающий его.
* Удалённые копирующий конструктор и копирующий оператор присваивания.

`shared_ptr` также должен иметь:

* Копирующий оператор присваивания.
* Копирующий конструктор.

Даже если сам указатель константный, то данные, на которые он указывает, могут быть неконстантны
(а можно и `shared_ptr<const int>` сделать).
Вам требуется самостоятельно добавить `[[nodiscard]]` и `explicit`.
Все операции работают за константное время.

### Гарантии
* Тип `T` не является `void`, массивом, ссылкой или функцией.
* Тип `T` будет полным (complete) при выполнении любой из следующих операций над `shared_ptr` или над `unique_ptr` с `Deleter` по умолчанию:
  * Любой оператор присваивания
  * Метод `reset()`
  * Оператор `->`
  * Уничтожение (также тип `T` будет иметь деструктор)
* Для `unique_ptr` с пользовательским `Deleter` полнота `T` гарантируется только при одной операции:
  * Оператор `->`
* Гарантируется, что тип `Deleter` является полным и, помимо `operator(T*)` и деструктора, поддерживает следующие операции:
  * Конструктор по умолчанию, если используется `unique_ptr::unique_ptr()` или `unique_ptr::unique_ptr(T*)`
  * Конструктор копирования или перемещения (в зависимости от ситуации), если экземпляр `Deleter` передаётся в конструктор `unique_ptr`
  * Конструктор перемещения, если `unique_ptr` перемещается или меняется местами при помощи `swap`
  * Если поддерживается конструктор копирования, то конструктор перемещения тоже доступен и не запрещён (в крайнем случае просто копирует)

### Частичные решения
Вы можете реализовать любой префикс из трёх подзаданий ниже и получить частичные баллы:

1. `unique_ptr` без поддержки произвольного `Deleter`, используйте `delete` напрямую
2. `unique_ptr` целиком
3. `shared_ptr` целиком

## Инструкция по сдаче
[Схема стандартная](../common/#формат-сдачи): вы должны выполнить
задание в отдельной ветке и создать Pull Request.
В этом задании должно хватить веб-интерфейса GitHub, если возникают проблемы — попросите практика помочь.

Если вы хотите сдать только некоторые части задания: отключите соответствующие автотесты,
закомментировав строки `#define TEST_DELETER` (в `unique_ptr_test.cpp`) и `#define TEST_SHARED_PTR` (в `shared_ptr_test.cpp`).

## Система оценки
* Задание оценивается в 10 баллов: 6 за корректность, 4 за стиль.
  * Если не проходит хотя бы одна автопроверка или неверно назван PR, вы получаете ноль.
  * Вы не можете получить за стиль больше баллов, чем за корректность.
* Вы можете сдать любой префикс частей:
  |Выполненные части|Макс. корректность|Макс. стиль|Макс. итог|
  |---|---|---|---|
  |1  |2  |1  | 3|
  |1-2|4  |2  | 6|
  |1-3|6  |4  |10|

## Сроки сдачи
Задание выдано 12 января 2022 (среда),
окончательные уточнения (при их наличии) ожидаются не позже 13 января (четверг).
Ниже в каждом случае указано московское время.

* **Дедлайн сдачи:** 19 января (среда), **22**:59.
* Ожидаемый срок проверки: 26 января (среда).
* Если первая попытка сдачи достаточно разумна (на усмотрение принимающего),
  то вы можете сделать ещё попытку исправлений или даже несколько.
  * Предложение актуально даже если вы получили автоматический ноль за первую попытку.
  * Выставляется максимум из всех попыток.
* **Срок исправлений**: 2 февраля (среда), **22**:59.
